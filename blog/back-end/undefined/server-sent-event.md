---
icon: message-arrow-down
---

# Server Sent Event를 굳이 쓸 곳이 있을까?

“네트워크 제약도 없는데, 왜 WebSocket 대신 SSE를 써?”



### 1. 짧은 복습 - WebSocket vs. SSE

| 구분     | WebSocket              | Server-Sent Event                 |
| ------ | ---------------------- | --------------------------------- |
| 연결 형식  | HTTP → **Upgrade 101** | 순수 HTTP 스트리밍                      |
| 통신 방향  | **양방향** (duplex)       | **단방향** (서버 → 클라)                 |
| 메시지 포맷 | 텍스트·바이너리               | 텍스트(UTF-8)                        |
| 재접속    | 직접 구현 필요               | `EventSource` 내장(`Last-Event-ID`) |
| CDN 중계 | 기본적으로 불가               | **가능** (HTTP keep-alive)          |
| 코드 난이도 | 프레임 파서·Ping/Pong       | `response.flush()` 만 있으면 끝        |

> **결론 미리 보기**\
> “**양방향성이 꼭 필요하지 않은** 대규모 팬-아웃 스트림”이라면,\
> &#x20;SSE가 더 단순하다.

### 2. 양방향이 _아닌_ 순간, SSE가 빛나는 이유

#### 2-1. **대규모 읽기 전용 “팬-아웃”**

* **시나리오**: 주가·환율·스포츠 점수·라이브 블로그 등 — “한 곳에서 계속 흘러나오는 데이터를 수천 명이 본다”.
* **이점**
  1. **CDN Request Collapsing**
     * Fastly, CloudFront, Cloudflare 등은 동일 URL의 장기 HTTP 응답을 _한 커넥션_ 으로 받아 다수 클라이언트에 복사.\
       → 오리진 서버 커넥션 **1 개**로 수만 명을 감당.
  2. **로드밸런서 셋업 ZERO**
     * 그냥 80/443 포트 HTTP다. Nginx-ingress, ALB 모두 기본값으로 통과.

#### 2-3. **자동 재생성 가능한 로그·프로그레스 바**

* 빌드 로그, 대용량 파일 업로드 진행률, AI 토큰 스트리밍처럼\
  &#xNAN;**“끊겨도 이어받기(Resume)만 되면 된다”** 는 류.
  * `EventSource` 가 `Last-Event-ID` 헤더로 복구 — 핸드셰이크 로직 불필요.
  * 뒤늦게 탭을 열어도 _과거 이벤트_ 를 빠르게 재전송할 수 있어 UX가 깔끔.

#### 2-4. **테스트·프로토타이핑 속도**

* Spring MVC `SseEmitter`, Express `res.write()`, FastAPI `yield bytes` …\
  → **5-10 줄**로 동작 확인 → 비즈니스 로직 집중 가능.
* 이후 “역할이 커져서 양방향이 필요”하면 **WebSocket로 갈아타도 데이터 모델 그대로 재활용**.

### 3. “네트워크는 OK”라 해도 SSE가 **실제**로 절약하는 것

| 관점           | SSE가 절약하는 리소스                                                       |
| ------------ | ------------------------------------------------------------------- |
| **개발 시간**    | 프레임 파서·Ping 타이머·세션 관리 없이도 동작                                        |
| **운영 복잡도**   | LB, 프록시, Observability 스택이 전부 HTTP 기준이면 그대로 재사용                     |
| **클라이언트 코드** | 브라우저 `EventSource` 한 줄, 모바일은 `OkHttp.newBuilder().get().build()` 정도 |
| **서버 메모리**   | 한 방향 버퍼만 유지 → 초당 수천 명 접속이라도 메모리 프로파일이 예측 가능                         |
| **비용**       | CDN 엣지-캐싱과 커넥션 공유 덕분에 오리진 연결 수 급감                                   |

### 4. 언제는 **절대** SSE로 부족한가?

| 빨간불 체크                          | 왜 안 되는가                            |
| ------------------------------- | ---------------------------------- |
| **클라이언트 ↔ 서버 상호작용** (채팅, 공동 편집) | 업로드마다 HTTP POST → 헤더 수백 B + RTT 폭증 |
| **바이너리 스트림** (게임 상태, 영상 프레임)    | SSE는 텍스트만, base64 인코딩 시 대역폭 ×1.37  |
| **밀리초 단위 지연 민감**                | POST 왕복이 50-100 ms를 먹을 수 있음        |
| **프런트 단 한 소켓에 다채널 다중화** 가 필요    | SSE는 커넥션당 1 스트림; 브라우저 6-커넥션 제한에 걸림 |

> 위 조건이 **하나라도** 중요하다면 WebSocket.



### 5. CloudFlare를 사용할 경우

> “발화자는 1 명, 청취자는 1 만 명”처럼 **대규모 읽기-전용 스트림**이라면\
> **SSE + CloudFlare** 조합이 WebSocket보다 **훨씬 저렴하고 간단**.

| CloudFlare 메커니즘                       | SSE에 유리한 이유                                                                      | 효과                                             |
| ------------------------------------- | -------------------------------------------------------------------------------- | ---------------------------------------------- |
| **Request Collapsing** (캐시 락)         | 동일 URL·헤더의 요청이 몰리면 POP(엣지)가 **첫 1 건만** 오리진으로 전송하고, 그 스트림을 뒤이어 접속한 모든 사용자가 **공유** | 오리진(TCP·TLS) 커넥션 수 **1 개로 수렴** → CPU·트래픽 비용 급감 |
| **Concurrent Streaming Acceleration** | 캐시 미스 상태에서도 “다운로드 중인 바이트”를 다수 클라이언트에게 **실시간 복제**                                 | ‘1 → N’ 라이브 브로드캐스트를 **CDN 레이어에서 자동 팬-아웃**      |
| **POP 지역 분산**                         | 서울 POP은 서울 사용자에게, 도쿄 POP은 도쿄 사용자에게 각각 스트림을 복제                                    | 지연 ↓, 오리진 부하는 지역별로 여전히 1 커넥션                   |
| **TLS 세션 재활용**                        | POP↔오리진 연결을 keep-alive로 장기 유지                                                    | 핸드셰이크·암복호화 오버헤드 최소화                            |

**설계 팁**

1. **요청을 완전히 동일하게**
   * URL·헤더가 같아야 Request Collapsing이 동작.
   * 인증이 필요하면 _쿠키 없는 퍼블릭 토큰_ 등을 고려해 URL을 통일.
2. **Late Joiner 대책**
   * CloudFlare는 “이미 열린 스트림”에 중간 합류시 약간 지연이 생길 수 있음.
   * **1–2 분마다 SSE 연결을 재수립**(segment-SSE) 하면 새 접속자도 즉시 CDN 팬-아웃의 혜택을 봄.

**언제 WebSocket이 여전히 필요할까?**

* 각 사용자에게 **다른 데이터**를 보내야 하거나
* **양방향** 상호작용(채팅, 버퍼 없는 RT 게임)이 필수라면\
  → CloudFlare CDN이 프레임을 해석해 줄 수 없으므로 **오리진-레벨 팬-아웃(WebSocket + 브로커)** 을 써야 합니다.

> **요약**\
> CloudFlare를 앞단에 두면 “1 개 오리진 SSE 스트림 → 1 만 명” 구조가 **POP에서 자동 복제**되어 오리진 리소스가 상수(1 커넥션)로 유지됩니다.\
> **동일 콘텐츠를 대부분의 사람들이 ‘보기만’ 하는 서비스**라면, 별도 팬-아웃 코드를 짤 필요 없이 **SSE + CloudFlare** 만으로도 실시간 브로드캐스트를 충분히 소화할 수 있다.
