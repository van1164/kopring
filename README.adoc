= kopring
:toc:

ifndef::imagesdir[:imagesdir: images]
image::kopring.png[scaledwidth=10%]



= 컨트롤러 활용
``` kotlin
@Controller
class MainController {

    @GetMapping("")
    @ResponseBody
    fun mainGetMap(model : Model): String {
        return "test"
    }
}
```

= JUnit을 사용한 테스트
``` kotlin
    @Test
    fun mainGetMap() {
        println(">> Assert getMapping()")
        val entity = restTemplate.getForEntity<String>("/")
        assertThat(entity.statusCode).isEqualTo(HttpStatus.OK)
        assertThat(entity.body).contains("test")
    }
```

= JPA  활용
== JPA 사용하는 이유
1. 생산성 => JDBC API와 SQL 문을 모두 작성해야하는 문제 해결
2. 유지 보수 => SQL에 의존하지 않기 때문에 수정할 코드가 줄어듦
3. 성능  => JPA라이브러리는 수많은 최적화로 내가 짜는거보다 성능 좋음!

= Entity 생성 기초

[source,kotlin]
----
@Entity
@Table (name = "MEMBER")
data class Member (
    @Id
    @Column(name = "ID")
    private val id : String?,

)
----

== Column 어노테이션에 DDL 조건 추가

[source,kotlin]
----
    @Id
    @Column(name = "ID", nullable = false, length = 16)
    val id : String,
----

== ENTITY에 JSON객체 사용하기

[source,kotlin]
----
@Entity
@Table(name = "USER")
data class User(
    @Type(value = JsonType::class)
    @Column(name = "vote_list", columnDefinition = "longtext")
    val voteList: HashMap<String,Any>,
----

이렇게 Type을 JsonType으로 columnDefinition을 longtext로 설정하고 변수 타입을 HashMap으로 지정해주면 된다.


== 기본키 생성전략

=== 기본키 직접할당 전략

[source,kotlin]
----
val member = Member(  )
member.setId("id")  // id를 직접 넣어주는 방식
em.persist(member)
----

=== IDENTITY 전략

[source,kotlin]
----
data class Member (
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    val id : String,
----

이 전략을 사용하면 데이터베이스가 자동으로 기본키를 생성하게 하는 전략으로 id를 쿼리를 데이터베이스에 전송한 후에 알 수있다.

영속 상태가 되기위해서는 id가 필요하기 때문에 em.persist()를 호출하는 즉시 데이터베이스에 전송된다.

=== Sequence 전략

[source,kotlin]
----
data class Member (
    @Id
    @GeneratedValue(strategy = GenerationType.SEQUENCE, generator = "SEQ_GENERATOR")
    val id : String,
----

유일한 값을 순서대로 생성하는 시퀀스를 사용한 방식으로 오라클, H2등 시퀀스를 제공하는 DB에서만 사용가능.

IDENTITY와 다르게 em.persist()를 호출할 때 시퀀스를  사용해서 id를 조회해서 엔티티에 넣는다. 그후 commit을 하면 그때 디비에 저장된다.

=== 테이블 전략

[source,kotlin]
----
data class Member (
    @Id
    @GeneratedValue(strategy = GenerationType.Table, generator = "SEQ_GENERATOR")
    val id : String,
----

SEQ_GENERATOR라는 이름의 테이블에 다음 시퀀스 값을 가지도록 만들어 놓고 그 테이블을 generator로 매핑한다.

그럼 그 테이블에서 자동적으로 원하는 엔티티에 id를 다음 시퀀스로 연결한다.

=== Auto 전략

[source,kotlin]
----
data class Member (
    @Id
    @GeneratedValue(strategy = GenerationType.Auto)
    val id : String,
----

JPA가 데이터베이스에 따라 위의 전략들중 하나를 자동으로 선택한다.

= 연관관계 매핑 기초

== @ManyToOne
[source,kotlin]
----
@Entity
@Table (name = "MEMBER")
data class Member (
    @ManyToOne
    @JoinColumn(name = "TEAM_ID") // 매핑할 컬럼명
    var team : Team? = null  // 매핑할 객체 선언
----

[source,kotlin]
----
@Entity
@Table(name = "TEAM")
data class Team(
    @Id
    @GeneratedValue
    @Column(name = "TEAM_ID") // 매핑되는 컬럼명
    val id :Long? =null,
)

----

=== 테스트코드

[source,kotlin]
----
@Test
fun createTeamAndMemberIntoTeam(){
	val team = service.createNewTeam("team1")  // Team객체 생성후 영속하는 함수
	val member = Member(name = "sihwan", passWord = "testPW")
	service.registerMember(member,team)
}
----
여기서 중요한 점은 팀을 member에 넣고 영속시키기 전에 팀을 먼저 영속시켜야 한다.

== @OneToMany + 양방향 매핑

[source,kotlin]
----
@OneToMany(mappedBy = "team")
val members : MutableList<Member> = mutableListOf<Member>()
}
----
mappedBy는 연관관계를 갖는 다른 테이블에 필드를 쓴다.

mappedBy를 넣은 쪽은 연관관계의 주인이 아니기 때문에 수정을 할 수 없다.

[source,kotlin]
----
@Entity
@Table (name = "MEMBER")
class Member (
    @ManyToOne
    @JoinColumn(name = "TEAM_ID")
    var team : Team? = null
) {
    fun teamSet(team: Team) {
        if (this.team != null){
            this.team!!.members.remove(this)
        }
        this.team = team
        team.members.add(this)
    }
}
----

team을 넣는다고 해서 연관 테이블에 리스트에 추가되지 않기 때문에 직접 넣어주어야 한다.

== 연관관계에 있는 데이터 삭제
데이터를 삭제하고 싶을데 관계를 가지고 있는 테이블이 있으면 그 데이터와 연관된 곳에서 모두 영속을 해지해야 한다.

[source,kotlin]
----
fun deleteTeam(teamName : String){
	val members = jpqlQuery.findMembersByTeamName(teamName)
	members?.forEach {
	    it.team = null
	}
	val team =jpqlQuery.findTeamByTeamName(teamName)
	em.remove(team)
}
----
이렇게 teamName을 가진 team을 삭제하고 싶을 때는  teamName을 가진 member들을 찾아서 member.team을 null로 바꿔주고 remove 해야한다.

= JPQL
JPQL은 엔티티 객체를 조회하는 객체지향 쿼리다.

== where절로 값찾기
[source,kotlin]
----
fun findTeamByTeamName(teamName : String): Team? {
	val jpql = "select t from Team t where t.name =: name"
	return em.createQuery(jpql, Team::class.java)
	    .setParameter("name", teamName)
	    .singleResult  // 값이 한개일 경우
	// .resultList  // 값이 여러개일 경우
}
----
팀이름으로 팀 검색하는 쿼리

== 연관된 테이블 JOIN후 where절로 조건에 맞는 값 찾기
[source,kotlin]
----
fun findMembersByTeamName(teamName: String): MutableList<Member>? {
	val jpql = "select m from Member m join m.team t where t.name =: teamName"
	return em.createQuery(jpql, Member::class.java)
	    .setParameter("teamName", teamName)
	    .resultList
}
----
특이하게 select *로 작성하면 안된다. Member타입의 m과 m.team타입의 t를 조인하고 where절로 조건을 추가하는 코드이다.

= Redis 사용

== RedisConfig 작성
[source,kotlin]
----
@Configuration(value = "redisConfig")
@EnableRedisRepositories
@RequiredArgsConstructor
class RedisConfig {

    @Value("\${spring.data.redis.host}")
    var host : String

    @Value("\${spring.data.redis.port}")
    var port : Int


    @Bean
    fun redisConnectionFactory(): RedisConnectionFactory? {
        val lettuceConnectionFactory = LettuceConnectionFactory(host, port)
        lettuceConnectionFactory.start()
        return lettuceConnectionFactory
    }

    @Bean
    fun redisTemplate(): RedisTemplate<String, String> {
        val redisTemplate = RedisTemplate<String, String>()
        redisTemplate.connectionFactory = redisConnectionFactory()
        redisTemplate.keySerializer = StringRedisSerializer()
        redisTemplate.valueSerializer = StringRedisSerializer()
        redisTemplate.afterPropertiesSet()
        return redisTemplate
    }
}
----

== RedisRepository 구현

[source,kotlin]
----
@Repository
class RedisRepository {

    val redisTemplate by lazy { RedisConfig().redisTemplate() }

    fun save(jwt : String, email : String){
        redisTemplate.opsForValue().set(jwt,email)
    }

    fun loadByJwt(jwt : String): String? {
        return redisTemplate.opsForValue().get(jwt)
    }

}
----

= Spring Security

== OAuth 2.0

=== Google

==== OAuth 유저 서비스 커스텀 구현
[source,kotlin]
----
@Service
class OAuth2UserService : DefaultOAuth2UserService() {

    override fun loadUser(userRequest: OAuth2UserRequest?): OAuth2User {
	// 동작
        return super.loadUser(userRequest)
    }
}
----
OAuth로 사용자 받아오는 서비스 구현

==== SecurityConfig 파일 구현
[source,kotlin]
----
import org.springframework.security.config.annotation.web.invoke
@Configuration
@EnableWebSecurity
class SecurityConfig {
    @Bean
    fun filterChain(http: HttpSecurity): SecurityFilterChain {
        http { // kotlin DSL
            httpBasic { disable() }
            csrf { disable() }
            cors { }
            authorizeRequests {
                authorize("/user/**", hasAuthority("ROLE_USER"))
            }
            oauth2Login {
                loginPage = "/loginPage"
                defaultSuccessUrl("/",true)
                userInfoEndpoint {  }
            }
        }
        return http.build()
    }
----
websecurityconfigureradapter가 Deprecated되면서 Kotlin은 Kotlin DSL을 사용해야 하게 됨.

따라서

import org.springframework.security.config.annotation.web.invoke 를 꼭 넣어줘야함

== SuccessHandler 구현

[source,kotlin]
----
    @Bean
    fun filterChain(http: HttpSecurity): SecurityFilterChain {
        http {
		'''
            oauth2Login {
                '''
                authenticationSuccessHandler = OAuthSuccessHandler()
            }
----
filterChain에 http.oauth2Login 에 authenticationSuccessHandler를 추가하고 핸들러를 등록한다.

[source,kotlin]
----
@Component(value = "authenticationSuccessHandler")
class OAuthSuccessHandler : AuthenticationSuccessHandler {
    // OAuth로그인후 불러와서 할 동작구현
    override fun onAuthenticationSuccess(request: HttpServletRequest, response: HttpServletResponse, authentication: Authentication) {
        val oAuth2User = authentication.principal as OAuth2User
        val name = oAuth2User.attributes["name"] as String
        val email = oAuth2User.attributes["email"] as String
}
    }
}
----

= 엔티티 메니저
== 엔티티 매니저 설정

[source,kotlin]
----
	val emf = Persistence.createEntityManagerFactory("jpaTest")
	val em = emf.createEntityManager()
----

== 트랜잭션 관리

[source,kotlin]
----
	val tx = em.transaction
	try {
		tx.begin()
		logic(em)
		tx.commit()
	} catch (e: Exception) {
		tx.rollback()
	} finally {
		em.close()
	}
----

== repository에서 em과 tx 활용

[source, kotlin]
----
class MemoryMemberRepository : MemberRepository {

    override val em: EntityManager
        get() = EntityManagerObject.em
    override val tx: EntityTransaction
        get() = EntityManagerObject.tx

    override fun save(member: Member) {
        tx.begin()
        em.persist(member)
        tx.commit()
    }

    override fun findById(id: String): Member {
        return em.find(Member::class.java, id)
    }

}

----

= ERROR

== Unable to load class [org.h2.Driver] 
h2 사용시 생기는 오류로 build.gradle.kts에 의존성 추가로 해결
```kotlin
	runtimeOnly ("com.h2database:h2")
	testImplementation ("org.springframework.boot:spring-boot-starter-test")
```

== Unable to locate persister
JPA가 자동으로 Entity 클래스를 불러오지 못하는 상황이 생겼다.

여러가지 방법을 시도했지만 안됐고, 해결한 방법은 persistence.xml에 직접 class를 추가해준 것이다.

```xml
    <persistence-unit name="jpaTest">
        <class> com.shan.kopring.data.model.Member</class> //직접 추가한 부분
        <properties>
		'''

persistence.xml
```

== Could not find mysql:mysql-connector-java
mysql 연동하는 과정에서 생긴 오류이다. 이유는 MySQL 8.0.31부터 클래스가 변경되었다. 따라서

```kotlin
dependencies {
	//implementation ("mysql:mysql-connector-java") 변경전
	implementation ("com.mysql:mysql-connector-j")  // 변경후
```

== org.hibernate.PersistentObjectException: detached entity passed to persist
```kotlin
data class Member (
    @Id
    @GeneratedValue(strategy = GenerationType.AUTO)
    val id : Long? = null,
```
이렇게 기본자생성 전략을 선택한 상태에서 직접 id를 넣어줄 경우 오류 발생함.

==  Type javax.servlet.http.HttpServletRequest not present
Spring Boot 3.XX 버전에서 Swagger를 적용시킬 때 생긴 오류

