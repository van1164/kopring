= kopring
:sectnum:
:toc: right
:toclevels: 1~3
:toc-title: Kopring 목차


ifndef::imagesdir[:imagesdir: images]
image::kopring.png[scaledwidth=10%]



= 컨트롤러 활용
``` kotlin
@Controller
class MainController {

    @GetMapping("")
    @ResponseBody
    fun mainGetMap(model : Model): String {
        return "test"
    }
}
```

= JUnit을 사용한 테스트
``` kotlin
    @Test
    fun mainGetMap() {
        println(">> Assert getMapping()")
        val entity = restTemplate.getForEntity<String>("/")
        assertThat(entity.statusCode).isEqualTo(HttpStatus.OK)
        assertThat(entity.body).contains("test")
    }
```

= JPA 
== JPA 사용하는 이유
1. 생산성 => JDBC API와 SQL 문을 모두 작성해야하는 문제 해결
2. 유지 보수 => SQL에 의존하지 않기 때문에 수정할 코드가 줄어듦
3. 성능  => JPA라이브러리는 수많은 최적화로 내가 짜는거보다 성능 좋음!

== Entity 생성 기초

[source,kotlin]
----
@Entity
@Table (name = "MEMBER")
data class Member (
    @Id
    @Column(name = "ID")
    private val id : String?,

)
----

=== Column 어노테이션에 DDL 조건 추가

[source,kotlin]
----
    @Id
    @Column(name = "ID", nullable = false, length = 16)
    val id : String,
----

=== ENTITY에 JSON객체 사용하기

[source,kotlin]
----
@Entity
@Table(name = "USER")
data class User(
    @Type(value = JsonType::class)
    @Column(name = "vote_list", columnDefinition = "longtext")
    val voteList: HashMap<String,Any>,
----

이렇게 Type을 JsonType으로 columnDefinition을 longtext로 설정하고 변수 타입을 HashMap으로 지정해주면 된다.


== 기본키 생성전략

=== 기본키 직접할당 전략

[source,kotlin]
----
val member = Member(  )
member.setId("id")  // id를 직접 넣어주는 방식
em.persist(member)
----

=== IDENTITY 전략

[source,kotlin]
----
data class Member (
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    val id : String,
----

이 전략을 사용하면 데이터베이스가 자동으로 기본키를 생성하게 하는 전략으로 id를 쿼리를 데이터베이스에 전송한 후에 알 수있다.

영속 상태가 되기위해서는 id가 필요하기 때문에 em.persist()를 호출하는 즉시 데이터베이스에 전송된다.

=== Sequence 전략

[source,kotlin]
----
data class Member (
    @Id
    @GeneratedValue(strategy = GenerationType.SEQUENCE, generator = "SEQ_GENERATOR")
    val id : String,
----

유일한 값을 순서대로 생성하는 시퀀스를 사용한 방식으로 오라클, H2등 시퀀스를 제공하는 DB에서만 사용가능.

IDENTITY와 다르게 em.persist()를 호출할 때 시퀀스를  사용해서 id를 조회해서 엔티티에 넣는다. 그후 commit을 하면 그때 디비에 저장된다.

=== 테이블 전략

[source,kotlin]
----
data class Member (
    @Id
    @GeneratedValue(strategy = GenerationType.Table, generator = "SEQ_GENERATOR")
    val id : String,
----

SEQ_GENERATOR라는 이름의 테이블에 다음 시퀀스 값을 가지도록 만들어 놓고 그 테이블을 generator로 매핑한다.

그럼 그 테이블에서 자동적으로 원하는 엔티티에 id를 다음 시퀀스로 연결한다.

=== Auto 전략

[source,kotlin]
----
data class Member (
    @Id
    @GeneratedValue(strategy = GenerationType.Auto)
    val id : String,
----

JPA가 데이터베이스에 따라 위의 전략들중 하나를 자동으로 선택한다.

== 연관관계 매핑 기초

=== @ManyToOne
[source,kotlin]
----
@Entity
@Table (name = "MEMBER")
data class Member (
    @ManyToOne
    @JoinColumn(name = "TEAM_ID") // 매핑할 컬럼명
    var team : Team? = null  // 매핑할 객체 선언
----

[source,kotlin]
----
@Entity
@Table(name = "TEAM")
data class Team(
    @Id
    @GeneratedValue
    @Column(name = "TEAM_ID") // 매핑되는 컬럼명
    val id :Long? =null,
)

----

==== 테스트코드

[source,kotlin]
----
@Test
fun createTeamAndMemberIntoTeam(){
	val team = service.createNewTeam("team1")  // Team객체 생성후 영속하는 함수
	val member = Member(name = "sihwan", passWord = "testPW")
	service.registerMember(member,team)
}
----
여기서 중요한 점은 팀을 member에 넣고 영속시키기 전에 팀을 먼저 영속시켜야 한다.

=== @OneToMany + 양방향 매핑

[source,kotlin]
----
@OneToMany(mappedBy = "team")
val members : MutableList<Member> = mutableListOf<Member>()
}
----
mappedBy는 연관관계를 갖는 다른 테이블에 필드를 쓴다.

mappedBy를 넣은 쪽은 연관관계의 주인이 아니기 때문에 수정을 할 수 없다.

[source,kotlin]
----
@Entity
@Table (name = "MEMBER")
class Member (
    @ManyToOne
    @JoinColumn(name = "TEAM_ID")
    var team : Team? = null
) {
    fun teamSet(team: Team) {
        if (this.team != null){
            this.team!!.members.remove(this)
        }
        this.team = team
        team.members.add(this)
    }
}
----

team을 넣는다고 해서 연관 테이블에 리스트에 추가되지 않기 때문에 직접 넣어주어야 한다.

=== 연관관계에 있는 데이터 삭제
데이터를 삭제하고 싶을데 관계를 가지고 있는 테이블이 있으면 그 데이터와 연관된 곳에서 모두 영속을 해지해야 한다.

[source,kotlin]
----
fun deleteTeam(teamName : String){
	val members = jpqlQuery.findMembersByTeamName(teamName)
	members?.forEach {
	    it.team = null
	}
	val team =jpqlQuery.findTeamByTeamName(teamName)
	em.remove(team)
}
----
이렇게 teamName을 가진 team을 삭제하고 싶을 때는  teamName을 가진 member들을 찾아서 member.team을 null로 바꿔주고 remove 해야한다.

== JPQL
JPQL은 엔티티 객체를 조회하는 객체지향 쿼리다.

=== where절로 값찾기
[source,kotlin]
----
fun findTeamByTeamName(teamName : String): Team? {
	val jpql = "select t from Team t where t.name =: name"
	return em.createQuery(jpql, Team::class.java)
	    .setParameter("name", teamName)
	    .singleResult  // 값이 한개일 경우
	// .resultList  // 값이 여러개일 경우
}
----
팀이름으로 팀 검색하는 쿼리

=== 연관된 테이블 JOIN후 where절로 조건에 맞는 값 찾기
[source,kotlin]
----
fun findMembersByTeamName(teamName: String): MutableList<Member>? {
	val jpql = "select m from Member m join m.team t where t.name =: teamName"
	return em.createQuery(jpql, Member::class.java)
	    .setParameter("teamName", teamName)
	    .resultList
}
----
특이하게 select *로 작성하면 안된다. Member타입의 m과 m.team타입의 t를 조인하고 where절로 조건을 추가하는 코드이다.

=== jpql로 조회한 값을 DTO와 연결하기
[source,kotlin]
----
val jpql = "select new 패키지명.DTO명(i.id,i.name) from Item i "
val voteList = em.createQuery(jpql,DTO명::class.java).resultList
}
----
여기서 특이한점은 JAVA와 같이 new를 사용하여야하고 DTO만 쓰면 안되며 패키지까지 써주어야한다.

=== NamedQuery로 정적쿼리 사용하기

Entity에 NamedQuery를 작성하고

```kotlin
@Entity
@NoArgsConstructor
@NamedQuery(
    name = "User.findByEmail",
    query = "select u from User u where u.email =: email"
)
@Table(name = "USER")
data class User(
'''
)
```

다음과 같이 사용하면 된다.

```kotlin
val user = em.createNamedQuery("User.findByEmail",User::class.java)
		.setParameter("email,email).getSingleResult
```

=== 서브쿼리

==== EXSITS

서브쿼리 결과가 존재하면 참.

```kotlin
val jqpl = "select m from Member m"
		+ "where exists(select t from m.team t where t.name = 'A')"
```

==== ALL, ANY

ALL은 서브쿼리 테이블 모든 값에 대해 조건이 만족해야 참.
ANY는 하나만 만족해도 참.

```kotlin
val jqpl = "select m from Member m"
		+ "where m.count > ALL (select n.count from NewMember n)" // m.count가 모든 n.count보다 커야지만 참.


val jqpl2 = "select m from Member m"
		+ "where m.count > ANY (select n.count from NewMember n)" // m.count가 n.count 하나보다만 크면 참.
```


== Criteria

JPQL보다 동적쿼리를 안전하게 생성하는 빌더 API
단, 가독성이 좀 떨어짐..

=== 쿼리 생성

```kotlin
val cb = em.criteriaBuilder  //CriteriaBuilder
val cq = cb.createQuery(User::class.java) //CriteriaQuery
```

==== Select

===== jpql코드

```kotln
val userJpql = "select distinct u from User u where u.email =: email"
val user = em.createQuery(userJpql, User::class.java).setParameter("email", email).singleResult
```

===== Criteria 코드

```kotln
val cb = em.criteriaBuilder
val cq = cb.createQuery(User::class.java).apply {
    val u = from(User::class.java)
    select(u)
    where(cb.equal(u.get<String>("email"),email))
}
val user = em.createQuery(cq).singleResult

```


= Redis 사용

== RedisConfig 작성
[source,kotlin]
----
@Configuration(value = "redisConfig")
@EnableRedisRepositories
@RequiredArgsConstructor
class RedisConfig {

    @Value("\${spring.data.redis.host}")
    var host : String

    @Value("\${spring.data.redis.port}")
    var port : Int


    @Bean
    fun redisConnectionFactory(): RedisConnectionFactory? {
        val lettuceConnectionFactory = LettuceConnectionFactory(host, port)
        lettuceConnectionFactory.start()
        return lettuceConnectionFactory
    }

    @Bean
    fun redisTemplate(): RedisTemplate<String, String> {
        val redisTemplate = RedisTemplate<String, String>()
        redisTemplate.connectionFactory = redisConnectionFactory()
        redisTemplate.keySerializer = StringRedisSerializer()
        redisTemplate.valueSerializer = StringRedisSerializer()
        redisTemplate.afterPropertiesSet()
        return redisTemplate
    }
}
----

== RedisRepository 구현

[source,kotlin]
----
@Repository
class RedisRepository {

    val redisTemplate by lazy { RedisConfig().redisTemplate() }

    fun save(jwt : String, email : String){
        redisTemplate.opsForValue().set(jwt,email)
    }

    fun loadByJwt(jwt : String): String? {
        return redisTemplate.opsForValue().get(jwt)
    }

}
----

= Spring Security

== OAuth 2.0

=== Google

==== OAuth 유저 서비스 커스텀 구현
[source,kotlin]
----
@Service
class OAuth2UserService : DefaultOAuth2UserService() {

    override fun loadUser(userRequest: OAuth2UserRequest?): OAuth2User {
	// 동작
        return super.loadUser(userRequest)
    }
}
----
OAuth로 사용자 받아오는 서비스 구현

==== SecurityConfig 파일 구현

[source,kotlin]
----
import org.springframework.security.config.annotation.web.invoke
@Configuration
@EnableWebSecurity
class SecurityConfig {
    @Bean
    fun filterChain(http: HttpSecurity): SecurityFilterChain {
        http { // kotlin DSL
            httpBasic { disable() }
            csrf { disable() }
            cors { }
            authorizeRequests {
                authorize("/user/**", hasAuthority("ROLE_USER"))
            }
            oauth2Login {
                loginPage = "/loginPage"
                defaultSuccessUrl("/",true)
                userInfoEndpoint {  }
            }
        }
        return http.build()
    }
----
websecurityconfigureradapter가 Deprecated되면서 Kotlin은 Kotlin DSL을 사용해야 하게 됨.

따라서

import org.springframework.security.config.annotation.web.invoke 를 꼭 넣어줘야함

== SuccessHandler 구현

[source,kotlin]
----
    @Bean
    fun filterChain(http: HttpSecurity): SecurityFilterChain {
        http {
		'''
            oauth2Login {
                '''
                authenticationSuccessHandler = OAuthSuccessHandler()
            }
----
filterChain에 http.oauth2Login 에 authenticationSuccessHandler를 추가하고 핸들러를 등록한다.

[source,kotlin]
----
@Component(value = "authenticationSuccessHandler")
class OAuthSuccessHandler : AuthenticationSuccessHandler {
    // OAuth로그인후 불러와서 할 동작구현
    override fun onAuthenticationSuccess(request: HttpServletRequest, response: HttpServletResponse, authentication: Authentication) {
        val oAuth2User = authentication.principal as OAuth2User
        val name = oAuth2User.attributes["name"] as String
        val email = oAuth2User.attributes["email"] as String
}
    }
}
----

== Filter추가로 JWT 토큰 검증하기

==== addFilterBefore로 추가한다

[source,kotlin]
----
class SecurityConfig(val oAuthSuccessHandler: OAuthSuccessHandler, val oAuthFailureHandler: OAuthFailureHandler) {
    @Bean
    fun filterChain(http: HttpSecurity): SecurityFilterChain {
        http {
	'''
            addFilterBefore<UsernamePasswordAuthenticationFilter> (JwtAuthenticationFilter(JwtTokenProvider()))
        }
        return http.build()
    }
}
----

==== JwtAuthenticationFilter 구현

[source,kotlin]
----
class JwtAuthenticationFilter(
        private val jwtTokenProvider: JwtTokenProvider
) : GenericFilterBean() {
    override fun doFilter(request: ServletRequest?, response: ServletResponse?, chain: FilterChain?) {
        val token = resolveToken(request as HttpServletRequest)

        if (token != null && jwtTokenProvider.validateToken(token)) {
            val authentication = jwtTokenProvider.getAuthentication(token)
            SecurityContextHolder.getContext().authentication = authentication
            println("doFilterChain:$authentication")
        }
        chain?.doFilter(request, response)
    }

    private fun resolveToken(request : HttpServletRequest) : String? {
        val bearerToken = request.getHeader("Authorization")
        return if (StringUtils.hasText(bearerToken) && bearerToken.startsWith("Bearer")) {
            bearerToken.substring(7)
        } else {
            null
        }
    }

}
----

= 엔티티 메니저
== 엔티티 매니저 설정

[source,kotlin]
----
	val emf = Persistence.createEntityManagerFactory("jpaTest")
	val em = emf.createEntityManager()
----

== 트랜잭션 관리

[source,kotlin]
----
	val tx = em.transaction
	try {
		tx.begin()
		logic(em)
		tx.commit()
	} catch (e: Exception) {
		tx.rollback()
	} finally {
		em.close()
	}
----

== repository에서 em과 tx 활용

[source, kotlin]
----
class MemoryMemberRepository : MemberRepository {

    override val em: EntityManager
        get() = EntityManagerObject.em
    override val tx: EntityTransaction
        get() = EntityManagerObject.tx

    override fun save(member: Member) {
        tx.begin()
        em.persist(member)
        tx.commit()
    }

    override fun findById(id: String): Member {
        return em.find(Member::class.java, id)
    }

}

----

== @Transactional과 @PersistenceContext를 활용한 중복코드 제거

==== 엔티티 매니저 의존성 주입 @PersistenceContext

``` kotlin
@Repository
class BaseRepository {
    @PersistenceContext
    lateinit var em : EntityManager
}
```

==== Transaction 반복코드 @Transactional로 대체

``` kotlin
/*
tx.begin()
---
tx.commit()
*/

위와 같은 역할을 @Transactional이 대신함.

@Transactional
class UserService(val userRepository: UserRepository):BaseService() {
```

== 코루틴을 사용하는 suspend function은 서비스 계층에서 한번에 @Transactional이 적용되지 않음.

=== 적용방법 추가예정

==== 현재 방식

===== 각 Repository 함수마다 @Transactional을 추가해준다.

= AWS

== S3

=== S3Config 작성
```kotlin
@Configuration
class S3Config(
        @Value("\${aws.s3.accessKey}")
        private val accessKey: String,
        @Value("\${aws.s3.secretKey}")
        private val secretKey: String,
) {
    @Bean
    fun amazonS3Client(): AmazonS3 {
        return AmazonS3ClientBuilder.standard()
                .withCredentials(
                        AWSStaticCredentialsProvider(BasicAWSCredentials(accessKey, secretKey))
                )
                .withRegion(Regions.AP_NORTHEAST_2)
                .build()
    }
}
```

=== coroutine사용한 여러 이미지 업로드 컨트롤러
```kotlin
@RestController
@RequestMapping("/")
class S3TestController(val amazonS3Client : AmazonS3) {
    @PostMapping("/multipart-files")
    suspend fun uploadMultipleFilesWithCoroutine(
            @RequestPart("uploadFiles") multipartFiles: List<MultipartFile>,
            @RequestParam type: String,
    ) = withContext(Dispatchers.IO) {
        val uploadJobs = multipartFiles.map {
            val objectMetadata = ObjectMetadata().apply {
                this.contentType = it.contentType
                this.contentLength = it.size
            }
            async {
                val putObjectRequest = PutObjectRequest(
                        "vote-share",
                        UUID.randomUUID().toString() + type,
                        it.inputStream,
                        objectMetadata,
                )
                amazonS3Client.putObject(putObjectRequest)
            }
        }
        uploadJobs.awaitAll()
        return@withContext "test Complete"
    }
}
```

= JUNIT

== Controller테스트

mockMvc를 사용해서 컨트롤러 테스트를 할 수 있다.

``` kotlin

lateinit var mockMvc: MockMvc

@Test
@WithMockUser()
fun getMyPage() {
	mockMvc.perform (
	    get("URL")
		.contentType(MediaType.APPLICATION_JSON)
		.header("Authorization","TestJWT")
	).andExpect(status().isOk)
	    .andExpect(jsonPath("$.email").value(testEmail))
	    .andExpect(jsonPath("$.accessToken").value(testJwt))
    .andExpect(jsonPath("$.nickName").value(testName))

}
```

== 비동기 처리된 컨트롤러 테스트방법 (feat. test Response가 빈값일 경우 이에 해당함.)

==== 위와 다르게 perform을 먼저하고 asyncDispatch를 통해서 진행해야한다.

``` kotlin
val mvcResult = mockMvc.perform(
    multipart("/api/v1/vote/create_vote")
	.file(testImage)
	.file(testImages)
	.file(voteDTO)
	.contentType(MediaType.MULTIPART_FORM_DATA)
	.header("Authorization", testJwt.grantType + " " + testJwt.accessToken)
    ).andExpect(status().isOk)
    .andExpect(request().asyncStarted())
    .andExpect { request().asyncResult("body") }
    .andReturn()

mockMvc.perform(asyncDispatch(mvcResult))
    .andExpect(status().isOk)
    .andExpect(jsonPath("$.반환값").조건)


```

[참고] https://docs.spring.io/spring-framework/reference/testing/spring-mvc-test-framework/async-requests.html


= Spring Batch

== 의존성 추가

```kotlin
	//Spring Batch
	implementation("org.springframework.boot:spring-batch-test")
	implementation("org.springframework.boot:spring-boot-starter-batch")
```

= ERROR

== Unable to load class [org.h2.Driver] 
h2 사용시 생기는 오류로 build.gradle.kts에 의존성 추가로 해결
```kotlin
	runtimeOnly ("com.h2database:h2")
	testImplementation ("org.springframework.boot:spring-boot-starter-test")
```

== Unable to locate persister
JPA가 자동으로 Entity 클래스를 불러오지 못하는 상황이 생겼다.

여러가지 방법을 시도했지만 안됐고, 해결한 방법은 persistence.xml에 직접 class를 추가해준 것이다.

```xml
    <persistence-unit name="jpaTest">
        <class> com.shan.kopring.data.model.Member</class> //직접 추가한 부분
        <properties>
		'''

persistence.xml
```

== Could not find mysql:mysql-connector-java
mysql 연동하는 과정에서 생긴 오류이다. 이유는 MySQL 8.0.31부터 클래스가 변경되었다. 따라서

```kotlin
dependencies {
	//implementation ("mysql:mysql-connector-java") 변경전
	implementation ("com.mysql:mysql-connector-j")  // 변경후
```

== org.hibernate.PersistentObjectException: detached entity passed to persist
```kotlin
data class Member (
    @Id
    @GeneratedValue(strategy = GenerationType.AUTO)
    val id : Long? = null,
```
이렇게 기본자생성 전략을 선택한 상태에서 직접 id를 넣어줄 경우 오류 발생함.

==  Type javax.servlet.http.HttpServletRequest not present
Spring Boot 3.XX 버전에서 Swagger를 적용시킬 때 생긴 오류

```kotlin
implementation("io.springfox:springfox-boot-starter:3.0.0")  // springfox 업데이트 안됨
```

springfox가 아닌 springdoc을 사용하면 오류 없이 사용가능하다.

```kotlin
//swagger
implementation("org.springdoc:springdoc-openapi-starter-webmvc-ui:2.3.0")
implementation("io.swagger.core.v3:swagger-annotations:2.2.16")
```

== com.mysql.cj.jdbc.exceptions.CommunicationsException: Communications link failure

docker에서 mysql을 연동할 때생긴 오류

application.properties에서 mysql주소를 localhost가 아닌 mysql 컨테이너 이름으로 설정시 DNS사용으로 해결

==== 이때 중요한건 application.properties와 persistence.xml에서도 디비를 변경해주어야한다.

```
spring.datasource.url=jdbc:mysql://my:3306/database-name
 <property name="javax.persistence.jdbc.url" value="jdbc:mysql://mysql:3306/database-name"/>
```


== 연관된 테이블 참조시 무한 루프와 StackOverFlow가 생기는 경우

Json으로 바꾸는 과정에서 서로 무한으로 불러오기 때문에 생기는 문제.
@JsonBackRefernece를 추가해주어서 그 컬럼을 json으로 바꾸지 않을 수있음.

``` kotlin
    @OneToMany(mappedBy = "user",fetch = FetchType.LAZY)
    @ToString.Exclude
    @JsonBackReference
    val teamList: MutableList<Team> = mutableListOf(),
```
